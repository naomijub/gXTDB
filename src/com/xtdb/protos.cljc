;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package com.xtdb.protos
;;;----------------------------------------------------------------------------------
(ns com.xtdb.protos
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [com.xtdb.protos :as com.xtdb.protos]
            [com.google.protobuf :as com.google.protobuf]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->Empty)
(declare ecis->Empty)
(declare new-Empty)
(declare cis->StatusResponse)
(declare ecis->StatusResponse)
(declare new-StatusResponse)
(declare cis->Evict)
(declare ecis->Evict)
(declare new-Evict)
(declare cis->Put)
(declare ecis->Put)
(declare new-Put)
(declare cis->OptionInt64)
(declare ecis->OptionInt64)
(declare new-OptionInt64)
(declare cis->EntityRequest)
(declare ecis->EntityRequest)
(declare new-EntityRequest)
(declare cis->SpeculativeTxResponse)
(declare ecis->SpeculativeTxResponse)
(declare new-SpeculativeTxResponse)
(declare cis->Delete)
(declare ecis->Delete)
(declare new-Delete)
(declare cis->SubmitRequest)
(declare ecis->SubmitRequest)
(declare new-SubmitRequest)
(declare cis->SubmitResponse)
(declare ecis->SubmitResponse)
(declare new-SubmitResponse)
(declare cis->EntityResponse)
(declare ecis->EntityResponse)
(declare new-EntityResponse)
(declare cis->SpeculativeTxRequest)
(declare ecis->SpeculativeTxRequest)
(declare new-SpeculativeTxRequest)
(declare cis->OptionDatetime)
(declare ecis->OptionDatetime)
(declare new-OptionDatetime)
(declare cis->EntityTxRequest)
(declare ecis->EntityTxRequest)
(declare new-EntityTxRequest)
(declare cis->EntityTxResponse)
(declare ecis->EntityTxResponse)
(declare new-EntityTxResponse)
(declare cis->Transaction)
(declare ecis->Transaction)
(declare new-Transaction)
(declare cis->OptionString)
(declare ecis->OptionString)
(declare new-OptionString)
(declare cis->Match)
(declare ecis->Match)
(declare new-Match)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; IdType
;-----------------------------------------------------------------------------
(def IdType-default :uuid)

(def IdType-val2label {0 :uuid
                       1 :keyword
                       2 :string
                       3 :int})

(def IdType-label2val (set/map-invert IdType-val2label))

(defn cis->IdType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get IdType-val2label val val)))

(defn- get-IdType [value]
  {:pre [(or (int? value) (contains? IdType-label2val value))]}
  (get IdType-label2val value value))

(defn write-IdType
  ([tag value os] (write-IdType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-IdType value) os)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; OptionInt64-value's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-OptionInt64-value [origkeyval]
  (cond
    (get-in origkeyval [:value :none]) (update-in origkeyval [:value :none] new-Empty)
    (get-in origkeyval [:value :some]) origkeyval
    :default origkeyval))

(defn write-OptionInt64-value [value os]
  (let [field (first value)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :none (serdes.core/write-embedded 1 v os)
      :some (serdes.core/write-Int64 2  {:optimize false} v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; OptionDatetime-value's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-OptionDatetime-value [origkeyval]
  (cond
    (get-in origkeyval [:value :none]) (update-in origkeyval [:value :none] new-Empty)
    (get-in origkeyval [:value :some]) origkeyval
    :default origkeyval))

(defn write-OptionDatetime-value [value os]
  (let [field (first value)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :none (serdes.core/write-embedded 1 v os)
      :some (serdes.core/write-String 2  {:optimize false} v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Transaction-transaction-type's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Transaction-transaction-type [origkeyval]
  (cond
    (get-in origkeyval [:transaction-type :put]) (update-in origkeyval [:transaction-type :put] new-Put)
    (get-in origkeyval [:transaction-type :delete]) (update-in origkeyval [:transaction-type :delete] new-Delete)
    (get-in origkeyval [:transaction-type :evict]) (update-in origkeyval [:transaction-type :evict] new-Evict)
    (get-in origkeyval [:transaction-type :match]) (update-in origkeyval [:transaction-type :match] new-Match)
    :default origkeyval))

(defn write-Transaction-transaction-type [transaction-type os]
  (let [field (first transaction-type)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :put (serdes.core/write-embedded 1 v os)
      :delete (serdes.core/write-embedded 2 v os)
      :evict (serdes.core/write-embedded 3 v os)
      :match (serdes.core/write-embedded 4 v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; OptionString-value's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-OptionString-value [origkeyval]
  (cond
    (get-in origkeyval [:value :none]) (update-in origkeyval [:value :none] new-Empty)
    (get-in origkeyval [:value :some]) origkeyval
    :default origkeyval))

(defn write-OptionString-value [value os]
  (let [field (first value)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :none (serdes.core/write-embedded 1 v os)
      :some (serdes.core/write-String 2  {:optimize false} v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Empty
;-----------------------------------------------------------------------------
(defrecord Empty-record []
  pb/Writer
  (serialize [this os])
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Empty"))

(s/def ::Empty-spec (s/keys :opt-un []))
(def Empty-defaults {})

(defn cis->Empty
  "CodedInputStream to Empty"
  [is]
  (map->Empty-record (tag-map Empty-defaults (fn [tag index] (case index [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Empty
  "Embedded CodedInputStream to Empty"
  [is]
  (serdes.core/cis->embedded cis->Empty is))

(defn new-Empty
  "Creates a new instance from a map, similar to map->Empty except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Empty-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Empty-spec init))))]}
  (map->Empty-record (merge Empty-defaults init)))

(defn pb->Empty
  "Protobuf to Empty"
  [input]
  (cis->Empty (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Empty-meta {:type "com.xtdb.protos.Empty" :decoder pb->Empty})

;-----------------------------------------------------------------------------
; StatusResponse
;-----------------------------------------------------------------------------
(defrecord StatusResponse-record [version index-version kv-store estimate-num-keys size revision consumer-state]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:version this) os)
    (serdes.core/write-Int32 2  {:optimize true} (:index-version this) os)
    (serdes.core/write-String 3  {:optimize true} (:kv-store this) os)
    (serdes.core/write-Int32 4  {:optimize true} (:estimate-num-keys this) os)
    (serdes.core/write-Int64 5  {:optimize true} (:size this) os)
    (serdes.core/write-embedded 6 (:revision this) os)
    (serdes.core/write-embedded 7 (:consumer-state this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.StatusResponse"))

(s/def :com.xtdb.protos.StatusResponse/version string?)
(s/def :com.xtdb.protos.StatusResponse/index-version int?)
(s/def :com.xtdb.protos.StatusResponse/kv-store string?)
(s/def :com.xtdb.protos.StatusResponse/estimate-num-keys int?)
(s/def :com.xtdb.protos.StatusResponse/size int?)

(s/def ::StatusResponse-spec (s/keys :opt-un [:com.xtdb.protos.StatusResponse/version :com.xtdb.protos.StatusResponse/index-version :com.xtdb.protos.StatusResponse/kv-store :com.xtdb.protos.StatusResponse/estimate-num-keys :com.xtdb.protos.StatusResponse/size]))
(def StatusResponse-defaults {:version "" :index-version 0 :kv-store "" :estimate-num-keys 0 :size 0})

(defn cis->StatusResponse
  "CodedInputStream to StatusResponse"
  [is]
  (map->StatusResponse-record (tag-map StatusResponse-defaults (fn [tag index] (case index 1 [:version (serdes.core/cis->String is)] 2 [:index-version (serdes.core/cis->Int32 is)] 3 [:kv-store (serdes.core/cis->String is)] 4 [:estimate-num-keys (serdes.core/cis->Int32 is)] 5 [:size (serdes.core/cis->Int64 is)] 6 [:revision (ecis->OptionString is)] 7 [:consumer-state (ecis->OptionString is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->StatusResponse
  "Embedded CodedInputStream to StatusResponse"
  [is]
  (serdes.core/cis->embedded cis->StatusResponse is))

(defn new-StatusResponse
  "Creates a new instance from a map, similar to map->StatusResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StatusResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StatusResponse-spec init))))]}
  (-> (merge StatusResponse-defaults init)
      (cond-> (some? (get init :revision)) (update :revision new-OptionString))
      (cond-> (some? (get init :consumer-state)) (update :consumer-state new-OptionString))
      (map->StatusResponse-record)))

(defn pb->StatusResponse
  "Protobuf to StatusResponse"
  [input]
  (cis->StatusResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StatusResponse-meta {:type "com.xtdb.protos.StatusResponse" :decoder pb->StatusResponse})

;-----------------------------------------------------------------------------
; Evict
;-----------------------------------------------------------------------------
(defrecord Evict-record [document-id id-type]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:document-id this) os)
    (write-IdType 2  {:optimize true} (:id-type this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Evict"))

(s/def :com.xtdb.protos.Evict/document-id string?)
(s/def :com.xtdb.protos.Evict/id-type (s/or :keyword keyword? :int int?))
(s/def ::Evict-spec (s/keys :opt-un [:com.xtdb.protos.Evict/document-id :com.xtdb.protos.Evict/id-type]))
(def Evict-defaults {:document-id "" :id-type IdType-default})

(defn cis->Evict
  "CodedInputStream to Evict"
  [is]
  (map->Evict-record (tag-map Evict-defaults (fn [tag index] (case index 1 [:document-id (serdes.core/cis->String is)] 2 [:id-type (cis->IdType is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Evict
  "Embedded CodedInputStream to Evict"
  [is]
  (serdes.core/cis->embedded cis->Evict is))

(defn new-Evict
  "Creates a new instance from a map, similar to map->Evict except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Evict-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Evict-spec init))))]}
  (map->Evict-record (merge Evict-defaults init)))

(defn pb->Evict
  "Protobuf to Evict"
  [input]
  (cis->Evict (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Evict-meta {:type "com.xtdb.protos.Evict" :decoder pb->Evict})

;-----------------------------------------------------------------------------
; Put
;-----------------------------------------------------------------------------
(defrecord Put-record [id-type xt-id document valid-time end-valid-time]
  pb/Writer
  (serialize [this os]
    (write-IdType 1  {:optimize true} (:id-type this) os)
    (serdes.core/write-String 2  {:optimize true} (:xt-id this) os)
    (serdes.core/write-embedded 3 (:document this) os)
    (serdes.core/write-embedded 4 (:valid-time this) os)
    (serdes.core/write-embedded 5 (:end-valid-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Put"))

(s/def :com.xtdb.protos.Put/id-type (s/or :keyword keyword? :int int?))
(s/def :com.xtdb.protos.Put/xt-id string?)

(s/def ::Put-spec (s/keys :opt-un [:com.xtdb.protos.Put/id-type :com.xtdb.protos.Put/xt-id]))
(def Put-defaults {:id-type IdType-default :xt-id ""})

(defn cis->Put
  "CodedInputStream to Put"
  [is]
  (map->Put-record (tag-map Put-defaults (fn [tag index] (case index 1 [:id-type (cis->IdType is)] 2 [:xt-id (serdes.core/cis->String is)] 3 [:document (com.google.protobuf/ecis->Struct is)] 4 [:valid-time (ecis->OptionDatetime is)] 5 [:end-valid-time (ecis->OptionDatetime is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Put
  "Embedded CodedInputStream to Put"
  [is]
  (serdes.core/cis->embedded cis->Put is))

(defn new-Put
  "Creates a new instance from a map, similar to map->Put except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Put-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Put-spec init))))]}
  (-> (merge Put-defaults init)
      (cond-> (some? (get init :document)) (update :document com.google.protobuf/new-Struct))
      (cond-> (some? (get init :valid-time)) (update :valid-time new-OptionDatetime))
      (cond-> (some? (get init :end-valid-time)) (update :end-valid-time new-OptionDatetime))
      (map->Put-record)))

(defn pb->Put
  "Protobuf to Put"
  [input]
  (cis->Put (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Put-meta {:type "com.xtdb.protos.Put" :decoder pb->Put})

;-----------------------------------------------------------------------------
; OptionInt64
;-----------------------------------------------------------------------------
(defrecord OptionInt64-record [value]
  pb/Writer
  (serialize [this os]
    (write-OptionInt64-value  (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.OptionInt64"))

(s/def ::OptionInt64-spec (s/keys :opt-un []))
(def OptionInt64-defaults {})

(defn cis->OptionInt64
  "CodedInputStream to OptionInt64"
  [is]
  (map->OptionInt64-record (tag-map OptionInt64-defaults (fn [tag index] (case index 1 [:value {:none (ecis->Empty is)}] 2 [:value {:some (serdes.core/cis->Int64 is)}] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->OptionInt64
  "Embedded CodedInputStream to OptionInt64"
  [is]
  (serdes.core/cis->embedded cis->OptionInt64 is))

(defn new-OptionInt64
  "Creates a new instance from a map, similar to map->OptionInt64 except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OptionInt64-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OptionInt64-spec init))))]}
  (-> (merge OptionInt64-defaults init)
      (convert-OptionInt64-value)
      (map->OptionInt64-record)))

(defn pb->OptionInt64
  "Protobuf to OptionInt64"
  [input]
  (cis->OptionInt64 (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record OptionInt64-meta {:type "com.xtdb.protos.OptionInt64" :decoder pb->OptionInt64})

;-----------------------------------------------------------------------------
; EntityRequest
;-----------------------------------------------------------------------------
(defrecord EntityRequest-record [id-type entity-id open-snapshot tx-id valid-time tx-time]
  pb/Writer
  (serialize [this os]
    (write-IdType 1  {:optimize true} (:id-type this) os)
    (serdes.core/write-String 2  {:optimize true} (:entity-id this) os)
    (serdes.core/write-Bool 3  {:optimize true} (:open-snapshot this) os)
    (serdes.core/write-embedded 4 (:tx-id this) os)
    (serdes.core/write-embedded 5 (:valid-time this) os)
    (serdes.core/write-embedded 6 (:tx-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.EntityRequest"))

(s/def :com.xtdb.protos.EntityRequest/id-type (s/or :keyword keyword? :int int?))
(s/def :com.xtdb.protos.EntityRequest/entity-id string?)
(s/def :com.xtdb.protos.EntityRequest/open-snapshot boolean?)

(s/def ::EntityRequest-spec (s/keys :opt-un [:com.xtdb.protos.EntityRequest/id-type :com.xtdb.protos.EntityRequest/entity-id :com.xtdb.protos.EntityRequest/open-snapshot]))
(def EntityRequest-defaults {:id-type IdType-default :entity-id "" :open-snapshot false})

(defn cis->EntityRequest
  "CodedInputStream to EntityRequest"
  [is]
  (map->EntityRequest-record (tag-map EntityRequest-defaults (fn [tag index] (case index 1 [:id-type (cis->IdType is)] 2 [:entity-id (serdes.core/cis->String is)] 3 [:open-snapshot (serdes.core/cis->Bool is)] 4 [:tx-id (ecis->OptionInt64 is)] 5 [:valid-time (ecis->OptionDatetime is)] 6 [:tx-time (ecis->OptionDatetime is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->EntityRequest
  "Embedded CodedInputStream to EntityRequest"
  [is]
  (serdes.core/cis->embedded cis->EntityRequest is))

(defn new-EntityRequest
  "Creates a new instance from a map, similar to map->EntityRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityRequest-spec init))))]}
  (-> (merge EntityRequest-defaults init)
      (cond-> (some? (get init :tx-id)) (update :tx-id new-OptionInt64))
      (cond-> (some? (get init :valid-time)) (update :valid-time new-OptionDatetime))
      (cond-> (some? (get init :tx-time)) (update :tx-time new-OptionDatetime))
      (map->EntityRequest-record)))

(defn pb->EntityRequest
  "Protobuf to EntityRequest"
  [input]
  (cis->EntityRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityRequest-meta {:type "com.xtdb.protos.EntityRequest" :decoder pb->EntityRequest})

;-----------------------------------------------------------------------------
; SpeculativeTxResponse
;-----------------------------------------------------------------------------
(defrecord SpeculativeTxResponse-record [valid-time tx-time tx-id entity-cache-size batch-size edn-document]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:valid-time this) os)
    (serdes.core/write-String 2  {:optimize true} (:tx-time this) os)
    (serdes.core/write-Int64 3  {:optimize true} (:tx-id this) os)
    (serdes.core/write-Int32 4  {:optimize true} (:entity-cache-size this) os)
    (serdes.core/write-Int32 5  {:optimize true} (:batch-size this) os)
    (serdes.core/write-String 6  {:optimize true} (:edn-document this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.SpeculativeTxResponse"))

(s/def :com.xtdb.protos.SpeculativeTxResponse/valid-time string?)
(s/def :com.xtdb.protos.SpeculativeTxResponse/tx-time string?)
(s/def :com.xtdb.protos.SpeculativeTxResponse/tx-id int?)
(s/def :com.xtdb.protos.SpeculativeTxResponse/entity-cache-size int?)
(s/def :com.xtdb.protos.SpeculativeTxResponse/batch-size int?)
(s/def :com.xtdb.protos.SpeculativeTxResponse/edn-document string?)
(s/def ::SpeculativeTxResponse-spec (s/keys :opt-un [:com.xtdb.protos.SpeculativeTxResponse/valid-time :com.xtdb.protos.SpeculativeTxResponse/tx-time :com.xtdb.protos.SpeculativeTxResponse/tx-id :com.xtdb.protos.SpeculativeTxResponse/entity-cache-size :com.xtdb.protos.SpeculativeTxResponse/batch-size :com.xtdb.protos.SpeculativeTxResponse/edn-document]))
(def SpeculativeTxResponse-defaults {:valid-time "" :tx-time "" :tx-id 0 :entity-cache-size 0 :batch-size 0 :edn-document ""})

(defn cis->SpeculativeTxResponse
  "CodedInputStream to SpeculativeTxResponse"
  [is]
  (map->SpeculativeTxResponse-record (tag-map SpeculativeTxResponse-defaults (fn [tag index] (case index 1 [:valid-time (serdes.core/cis->String is)] 2 [:tx-time (serdes.core/cis->String is)] 3 [:tx-id (serdes.core/cis->Int64 is)] 4 [:entity-cache-size (serdes.core/cis->Int32 is)] 5 [:batch-size (serdes.core/cis->Int32 is)] 6 [:edn-document (serdes.core/cis->String is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->SpeculativeTxResponse
  "Embedded CodedInputStream to SpeculativeTxResponse"
  [is]
  (serdes.core/cis->embedded cis->SpeculativeTxResponse is))

(defn new-SpeculativeTxResponse
  "Creates a new instance from a map, similar to map->SpeculativeTxResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SpeculativeTxResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SpeculativeTxResponse-spec init))))]}
  (map->SpeculativeTxResponse-record (merge SpeculativeTxResponse-defaults init)))

(defn pb->SpeculativeTxResponse
  "Protobuf to SpeculativeTxResponse"
  [input]
  (cis->SpeculativeTxResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SpeculativeTxResponse-meta {:type "com.xtdb.protos.SpeculativeTxResponse" :decoder pb->SpeculativeTxResponse})

;-----------------------------------------------------------------------------
; Delete
;-----------------------------------------------------------------------------
(defrecord Delete-record [document-id id-type valid-time end-valid-time]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:document-id this) os)
    (write-IdType 2  {:optimize true} (:id-type this) os)
    (serdes.core/write-embedded 3 (:valid-time this) os)
    (serdes.core/write-embedded 4 (:end-valid-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Delete"))

(s/def :com.xtdb.protos.Delete/document-id string?)
(s/def :com.xtdb.protos.Delete/id-type (s/or :keyword keyword? :int int?))

(s/def ::Delete-spec (s/keys :opt-un [:com.xtdb.protos.Delete/document-id :com.xtdb.protos.Delete/id-type]))
(def Delete-defaults {:document-id "" :id-type IdType-default})

(defn cis->Delete
  "CodedInputStream to Delete"
  [is]
  (map->Delete-record (tag-map Delete-defaults (fn [tag index] (case index 1 [:document-id (serdes.core/cis->String is)] 2 [:id-type (cis->IdType is)] 3 [:valid-time (ecis->OptionDatetime is)] 4 [:end-valid-time (ecis->OptionDatetime is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Delete
  "Embedded CodedInputStream to Delete"
  [is]
  (serdes.core/cis->embedded cis->Delete is))

(defn new-Delete
  "Creates a new instance from a map, similar to map->Delete except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Delete-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Delete-spec init))))]}
  (-> (merge Delete-defaults init)
      (cond-> (some? (get init :valid-time)) (update :valid-time new-OptionDatetime))
      (cond-> (some? (get init :end-valid-time)) (update :end-valid-time new-OptionDatetime))
      (map->Delete-record)))

(defn pb->Delete
  "Protobuf to Delete"
  [input]
  (cis->Delete (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Delete-meta {:type "com.xtdb.protos.Delete" :decoder pb->Delete})

;-----------------------------------------------------------------------------
; SubmitRequest
;-----------------------------------------------------------------------------
(defrecord SubmitRequest-record [tx-ops tx-time]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:tx-ops this) os)
    (serdes.core/write-embedded 2 (:tx-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.SubmitRequest"))

(s/def ::SubmitRequest-spec (s/keys :opt-un []))
(def SubmitRequest-defaults {:tx-ops []})

(defn cis->SubmitRequest
  "CodedInputStream to SubmitRequest"
  [is]
  (map->SubmitRequest-record (tag-map SubmitRequest-defaults (fn [tag index] (case index 1 [:tx-ops (serdes.complex/cis->repeated ecis->Transaction is)] 2 [:tx-time (ecis->OptionDatetime is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->SubmitRequest
  "Embedded CodedInputStream to SubmitRequest"
  [is]
  (serdes.core/cis->embedded cis->SubmitRequest is))

(defn new-SubmitRequest
  "Creates a new instance from a map, similar to map->SubmitRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SubmitRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SubmitRequest-spec init))))]}
  (-> (merge SubmitRequest-defaults init)
      (cond-> (some? (get init :tx-ops)) (update :tx-ops #(map new-Transaction %)))
      (cond-> (some? (get init :tx-time)) (update :tx-time new-OptionDatetime))
      (map->SubmitRequest-record)))

(defn pb->SubmitRequest
  "Protobuf to SubmitRequest"
  [input]
  (cis->SubmitRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SubmitRequest-meta {:type "com.xtdb.protos.SubmitRequest" :decoder pb->SubmitRequest})

;-----------------------------------------------------------------------------
; SubmitResponse
;-----------------------------------------------------------------------------
(defrecord SubmitResponse-record [tx-time tx-id]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:tx-time this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:tx-id this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.SubmitResponse"))

(s/def :com.xtdb.protos.SubmitResponse/tx-time string?)
(s/def :com.xtdb.protos.SubmitResponse/tx-id int?)
(s/def ::SubmitResponse-spec (s/keys :opt-un [:com.xtdb.protos.SubmitResponse/tx-time :com.xtdb.protos.SubmitResponse/tx-id]))
(def SubmitResponse-defaults {:tx-time "" :tx-id 0})

(defn cis->SubmitResponse
  "CodedInputStream to SubmitResponse"
  [is]
  (map->SubmitResponse-record (tag-map SubmitResponse-defaults (fn [tag index] (case index 1 [:tx-time (serdes.core/cis->String is)] 2 [:tx-id (serdes.core/cis->Int64 is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->SubmitResponse
  "Embedded CodedInputStream to SubmitResponse"
  [is]
  (serdes.core/cis->embedded cis->SubmitResponse is))

(defn new-SubmitResponse
  "Creates a new instance from a map, similar to map->SubmitResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SubmitResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SubmitResponse-spec init))))]}
  (map->SubmitResponse-record (merge SubmitResponse-defaults init)))

(defn pb->SubmitResponse
  "Protobuf to SubmitResponse"
  [input]
  (cis->SubmitResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SubmitResponse-meta {:type "com.xtdb.protos.SubmitResponse" :decoder pb->SubmitResponse})

;-----------------------------------------------------------------------------
; EntityResponse
;-----------------------------------------------------------------------------
(defrecord EntityResponse-record [xt-id content]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:xt-id this) os)
    (serdes.core/write-String 2  {:optimize true} (:content this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.EntityResponse"))

(s/def :com.xtdb.protos.EntityResponse/xt-id string?)
(s/def :com.xtdb.protos.EntityResponse/content string?)
(s/def ::EntityResponse-spec (s/keys :opt-un [:com.xtdb.protos.EntityResponse/xt-id :com.xtdb.protos.EntityResponse/content]))
(def EntityResponse-defaults {:xt-id "" :content ""})

(defn cis->EntityResponse
  "CodedInputStream to EntityResponse"
  [is]
  (map->EntityResponse-record (tag-map EntityResponse-defaults (fn [tag index] (case index 1 [:xt-id (serdes.core/cis->String is)] 2 [:content (serdes.core/cis->String is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->EntityResponse
  "Embedded CodedInputStream to EntityResponse"
  [is]
  (serdes.core/cis->embedded cis->EntityResponse is))

(defn new-EntityResponse
  "Creates a new instance from a map, similar to map->EntityResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityResponse-spec init))))]}
  (map->EntityResponse-record (merge EntityResponse-defaults init)))

(defn pb->EntityResponse
  "Protobuf to EntityResponse"
  [input]
  (cis->EntityResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityResponse-meta {:type "com.xtdb.protos.EntityResponse" :decoder pb->EntityResponse})

;-----------------------------------------------------------------------------
; SpeculativeTxRequest
;-----------------------------------------------------------------------------
(defrecord SpeculativeTxRequest-record [tx-ops]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:tx-ops this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.SpeculativeTxRequest"))

(s/def ::SpeculativeTxRequest-spec (s/keys :opt-un []))
(def SpeculativeTxRequest-defaults {:tx-ops []})

(defn cis->SpeculativeTxRequest
  "CodedInputStream to SpeculativeTxRequest"
  [is]
  (map->SpeculativeTxRequest-record (tag-map SpeculativeTxRequest-defaults (fn [tag index] (case index 1 [:tx-ops (serdes.complex/cis->repeated ecis->Transaction is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->SpeculativeTxRequest
  "Embedded CodedInputStream to SpeculativeTxRequest"
  [is]
  (serdes.core/cis->embedded cis->SpeculativeTxRequest is))

(defn new-SpeculativeTxRequest
  "Creates a new instance from a map, similar to map->SpeculativeTxRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SpeculativeTxRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SpeculativeTxRequest-spec init))))]}
  (-> (merge SpeculativeTxRequest-defaults init)
      (cond-> (some? (get init :tx-ops)) (update :tx-ops #(map new-Transaction %)))
      (map->SpeculativeTxRequest-record)))

(defn pb->SpeculativeTxRequest
  "Protobuf to SpeculativeTxRequest"
  [input]
  (cis->SpeculativeTxRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SpeculativeTxRequest-meta {:type "com.xtdb.protos.SpeculativeTxRequest" :decoder pb->SpeculativeTxRequest})

;-----------------------------------------------------------------------------
; OptionDatetime
;-----------------------------------------------------------------------------
(defrecord OptionDatetime-record [value]
  pb/Writer
  (serialize [this os]
    (write-OptionDatetime-value  (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.OptionDatetime"))

(s/def ::OptionDatetime-spec (s/keys :opt-un []))
(def OptionDatetime-defaults {})

(defn cis->OptionDatetime
  "CodedInputStream to OptionDatetime"
  [is]
  (map->OptionDatetime-record (tag-map OptionDatetime-defaults (fn [tag index] (case index 1 [:value {:none (ecis->Empty is)}] 2 [:value {:some (serdes.core/cis->String is)}] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->OptionDatetime
  "Embedded CodedInputStream to OptionDatetime"
  [is]
  (serdes.core/cis->embedded cis->OptionDatetime is))

(defn new-OptionDatetime
  "Creates a new instance from a map, similar to map->OptionDatetime except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OptionDatetime-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OptionDatetime-spec init))))]}
  (-> (merge OptionDatetime-defaults init)
      (convert-OptionDatetime-value)
      (map->OptionDatetime-record)))

(defn pb->OptionDatetime
  "Protobuf to OptionDatetime"
  [input]
  (cis->OptionDatetime (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record OptionDatetime-meta {:type "com.xtdb.protos.OptionDatetime" :decoder pb->OptionDatetime})

;-----------------------------------------------------------------------------
; EntityTxRequest
;-----------------------------------------------------------------------------
(defrecord EntityTxRequest-record [id-type entity-id open-snapshot tx-id valid-time tx-time]
  pb/Writer
  (serialize [this os]
    (write-IdType 1  {:optimize true} (:id-type this) os)
    (serdes.core/write-String 2  {:optimize true} (:entity-id this) os)
    (serdes.core/write-Bool 3  {:optimize true} (:open-snapshot this) os)
    (serdes.core/write-embedded 4 (:tx-id this) os)
    (serdes.core/write-embedded 5 (:valid-time this) os)
    (serdes.core/write-embedded 6 (:tx-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.EntityTxRequest"))

(s/def :com.xtdb.protos.EntityTxRequest/id-type (s/or :keyword keyword? :int int?))
(s/def :com.xtdb.protos.EntityTxRequest/entity-id string?)
(s/def :com.xtdb.protos.EntityTxRequest/open-snapshot boolean?)

(s/def ::EntityTxRequest-spec (s/keys :opt-un [:com.xtdb.protos.EntityTxRequest/id-type :com.xtdb.protos.EntityTxRequest/entity-id :com.xtdb.protos.EntityTxRequest/open-snapshot]))
(def EntityTxRequest-defaults {:id-type IdType-default :entity-id "" :open-snapshot false})

(defn cis->EntityTxRequest
  "CodedInputStream to EntityTxRequest"
  [is]
  (map->EntityTxRequest-record (tag-map EntityTxRequest-defaults (fn [tag index] (case index 1 [:id-type (cis->IdType is)] 2 [:entity-id (serdes.core/cis->String is)] 3 [:open-snapshot (serdes.core/cis->Bool is)] 4 [:tx-id (ecis->OptionInt64 is)] 5 [:valid-time (ecis->OptionDatetime is)] 6 [:tx-time (ecis->OptionDatetime is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->EntityTxRequest
  "Embedded CodedInputStream to EntityTxRequest"
  [is]
  (serdes.core/cis->embedded cis->EntityTxRequest is))

(defn new-EntityTxRequest
  "Creates a new instance from a map, similar to map->EntityTxRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityTxRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityTxRequest-spec init))))]}
  (-> (merge EntityTxRequest-defaults init)
      (cond-> (some? (get init :tx-id)) (update :tx-id new-OptionInt64))
      (cond-> (some? (get init :valid-time)) (update :valid-time new-OptionDatetime))
      (cond-> (some? (get init :tx-time)) (update :tx-time new-OptionDatetime))
      (map->EntityTxRequest-record)))

(defn pb->EntityTxRequest
  "Protobuf to EntityTxRequest"
  [input]
  (cis->EntityTxRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityTxRequest-meta {:type "com.xtdb.protos.EntityTxRequest" :decoder pb->EntityTxRequest})

;-----------------------------------------------------------------------------
; EntityTxResponse
;-----------------------------------------------------------------------------
(defrecord EntityTxResponse-record [xt-id content-hash valid-time tx-time tx-id]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:xt-id this) os)
    (serdes.core/write-String 2  {:optimize true} (:content-hash this) os)
    (serdes.core/write-String 3  {:optimize true} (:valid-time this) os)
    (serdes.core/write-String 4  {:optimize true} (:tx-time this) os)
    (serdes.core/write-Int64 5  {:optimize true} (:tx-id this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.EntityTxResponse"))

(s/def :com.xtdb.protos.EntityTxResponse/xt-id string?)
(s/def :com.xtdb.protos.EntityTxResponse/content-hash string?)
(s/def :com.xtdb.protos.EntityTxResponse/valid-time string?)
(s/def :com.xtdb.protos.EntityTxResponse/tx-time string?)
(s/def :com.xtdb.protos.EntityTxResponse/tx-id int?)
(s/def ::EntityTxResponse-spec (s/keys :opt-un [:com.xtdb.protos.EntityTxResponse/xt-id :com.xtdb.protos.EntityTxResponse/content-hash :com.xtdb.protos.EntityTxResponse/valid-time :com.xtdb.protos.EntityTxResponse/tx-time :com.xtdb.protos.EntityTxResponse/tx-id]))
(def EntityTxResponse-defaults {:xt-id "" :content-hash "" :valid-time "" :tx-time "" :tx-id 0})

(defn cis->EntityTxResponse
  "CodedInputStream to EntityTxResponse"
  [is]
  (map->EntityTxResponse-record (tag-map EntityTxResponse-defaults (fn [tag index] (case index 1 [:xt-id (serdes.core/cis->String is)] 2 [:content-hash (serdes.core/cis->String is)] 3 [:valid-time (serdes.core/cis->String is)] 4 [:tx-time (serdes.core/cis->String is)] 5 [:tx-id (serdes.core/cis->Int64 is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->EntityTxResponse
  "Embedded CodedInputStream to EntityTxResponse"
  [is]
  (serdes.core/cis->embedded cis->EntityTxResponse is))

(defn new-EntityTxResponse
  "Creates a new instance from a map, similar to map->EntityTxResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::EntityTxResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::EntityTxResponse-spec init))))]}
  (map->EntityTxResponse-record (merge EntityTxResponse-defaults init)))

(defn pb->EntityTxResponse
  "Protobuf to EntityTxResponse"
  [input]
  (cis->EntityTxResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record EntityTxResponse-meta {:type "com.xtdb.protos.EntityTxResponse" :decoder pb->EntityTxResponse})

;-----------------------------------------------------------------------------
; Transaction
;-----------------------------------------------------------------------------
(defrecord Transaction-record [transaction-type]
  pb/Writer
  (serialize [this os]
    (write-Transaction-transaction-type  (:transaction-type this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Transaction"))

(s/def ::Transaction-spec (s/keys :opt-un []))
(def Transaction-defaults {})

(defn cis->Transaction
  "CodedInputStream to Transaction"
  [is]
  (map->Transaction-record (tag-map Transaction-defaults (fn [tag index] (case index 1 [:transaction-type {:put (ecis->Put is)}] 2 [:transaction-type {:delete (ecis->Delete is)}] 3 [:transaction-type {:evict (ecis->Evict is)}] 4 [:transaction-type {:match (ecis->Match is)}] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Transaction
  "Embedded CodedInputStream to Transaction"
  [is]
  (serdes.core/cis->embedded cis->Transaction is))

(defn new-Transaction
  "Creates a new instance from a map, similar to map->Transaction except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Transaction-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Transaction-spec init))))]}
  (-> (merge Transaction-defaults init)
      (convert-Transaction-transaction-type)
      (map->Transaction-record)))

(defn pb->Transaction
  "Protobuf to Transaction"
  [input]
  (cis->Transaction (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Transaction-meta {:type "com.xtdb.protos.Transaction" :decoder pb->Transaction})

;-----------------------------------------------------------------------------
; OptionString
;-----------------------------------------------------------------------------
(defrecord OptionString-record [value]
  pb/Writer
  (serialize [this os]
    (write-OptionString-value  (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.OptionString"))

(s/def ::OptionString-spec (s/keys :opt-un []))
(def OptionString-defaults {})

(defn cis->OptionString
  "CodedInputStream to OptionString"
  [is]
  (map->OptionString-record (tag-map OptionString-defaults (fn [tag index] (case index 1 [:value {:none (ecis->Empty is)}] 2 [:value {:some (serdes.core/cis->String is)}] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->OptionString
  "Embedded CodedInputStream to OptionString"
  [is]
  (serdes.core/cis->embedded cis->OptionString is))

(defn new-OptionString
  "Creates a new instance from a map, similar to map->OptionString except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OptionString-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OptionString-spec init))))]}
  (-> (merge OptionString-defaults init)
      (convert-OptionString-value)
      (map->OptionString-record)))

(defn pb->OptionString
  "Protobuf to OptionString"
  [input]
  (cis->OptionString (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record OptionString-meta {:type "com.xtdb.protos.OptionString" :decoder pb->OptionString})

;-----------------------------------------------------------------------------
; Match
;-----------------------------------------------------------------------------
(defrecord Match-record [document-id id-type document valid-time]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:document-id this) os)
    (write-IdType 2  {:optimize true} (:id-type this) os)
    (serdes.core/write-embedded 3 (:document this) os)
    (serdes.core/write-embedded 4 (:valid-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Match"))

(s/def :com.xtdb.protos.Match/document-id string?)
(s/def :com.xtdb.protos.Match/id-type (s/or :keyword keyword? :int int?))

(s/def ::Match-spec (s/keys :opt-un [:com.xtdb.protos.Match/document-id :com.xtdb.protos.Match/id-type]))
(def Match-defaults {:document-id "" :id-type IdType-default})

(defn cis->Match
  "CodedInputStream to Match"
  [is]
  (map->Match-record (tag-map Match-defaults (fn [tag index] (case index 1 [:document-id (serdes.core/cis->String is)] 2 [:id-type (cis->IdType is)] 3 [:document (com.google.protobuf/ecis->Struct is)] 4 [:valid-time (ecis->OptionDatetime is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Match
  "Embedded CodedInputStream to Match"
  [is]
  (serdes.core/cis->embedded cis->Match is))

(defn new-Match
  "Creates a new instance from a map, similar to map->Match except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Match-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Match-spec init))))]}
  (-> (merge Match-defaults init)
      (cond-> (some? (get init :document)) (update :document com.google.protobuf/new-Struct))
      (cond-> (some? (get init :valid-time)) (update :valid-time new-OptionDatetime))
      (map->Match-record)))

(defn pb->Match
  "Protobuf to Match"
  [input]
  (cis->Match (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Match-meta {:type "com.xtdb.protos.Match" :decoder pb->Match})

