;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package com.xtdb.protos
;;;----------------------------------------------------------------------------------
(ns com.xtdb.protos
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->Empty)
(declare ecis->Empty)
(declare new-Empty)
(declare cis->OptionString)
(declare ecis->OptionString)
(declare new-OptionString)
(declare cis->StatusResponse)
(declare ecis->StatusResponse)
(declare new-StatusResponse)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; OptionString-value's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-OptionString-value [origkeyval]
  (cond
     (get-in origkeyval [:value :none]) (update-in origkeyval [:value :none] new-Empty)
     (get-in origkeyval [:value :some]) origkeyval
     :default origkeyval))

(defn write-OptionString-value [value os]
  (let [field (first value)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
     (case k
         :none (serdes.core/write-embedded 1 v os)
         :some (serdes.core/write-String 2  {:optimize false} v os)
         nil)))



;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Empty
;-----------------------------------------------------------------------------
(defrecord Empty-record []
  pb/Writer
  (serialize [this os]
)
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Empty"))

(s/def ::Empty-spec (s/keys :opt-un []))
(def Empty-defaults {})

(defn cis->Empty
  "CodedInputStream to Empty"
  [is]
  (->> (tag-map Empty-defaults
         (fn [tag index]
             (case index
               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->Empty-record)))

(defn ecis->Empty
  "Embedded CodedInputStream to Empty"
  [is]
  (serdes.core/cis->embedded cis->Empty is))

(defn new-Empty
  "Creates a new instance from a map, similar to map->Empty except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Empty-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Empty-spec init))))]}
  (-> (merge Empty-defaults init)
      (map->Empty-record)))

(defn pb->Empty
  "Protobuf to Empty"
  [input]
  (cis->Empty (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Empty-meta {:type "com.xtdb.protos.Empty" :decoder pb->Empty})

;-----------------------------------------------------------------------------
; OptionString
;-----------------------------------------------------------------------------
(defrecord OptionString-record [value]
  pb/Writer
  (serialize [this os]
    (write-OptionString-value  (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.OptionString"))

(s/def ::OptionString-spec (s/keys :opt-un []))
(def OptionString-defaults {})

(defn cis->OptionString
  "CodedInputStream to OptionString"
  [is]
  (->> (tag-map OptionString-defaults
         (fn [tag index]
             (case index
               1 [:value {:none (ecis->Empty is)}]
               2 [:value {:some (serdes.core/cis->String is)}]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->OptionString-record)))

(defn ecis->OptionString
  "Embedded CodedInputStream to OptionString"
  [is]
  (serdes.core/cis->embedded cis->OptionString is))

(defn new-OptionString
  "Creates a new instance from a map, similar to map->OptionString except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OptionString-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OptionString-spec init))))]}
  (-> (merge OptionString-defaults init)
      (convert-OptionString-value)
      (map->OptionString-record)))

(defn pb->OptionString
  "Protobuf to OptionString"
  [input]
  (cis->OptionString (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record OptionString-meta {:type "com.xtdb.protos.OptionString" :decoder pb->OptionString})

;-----------------------------------------------------------------------------
; StatusResponse
;-----------------------------------------------------------------------------
(defrecord StatusResponse-record [version index-version kv-store estimate-num-keys size revision consumer-state]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:version this) os)
    (serdes.core/write-Int32 2  {:optimize true} (:index-version this) os)
    (serdes.core/write-String 3  {:optimize true} (:kv-store this) os)
    (serdes.core/write-Int32 4  {:optimize true} (:estimate-num-keys this) os)
    (serdes.core/write-Int64 5  {:optimize true} (:size this) os)
    (serdes.core/write-embedded 6 (:revision this) os)
    (serdes.core/write-embedded 7 (:consumer-state this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.StatusResponse"))

(s/def :com.xtdb.protos.StatusResponse/version string?)
(s/def :com.xtdb.protos.StatusResponse/index-version int?)
(s/def :com.xtdb.protos.StatusResponse/kv-store string?)
(s/def :com.xtdb.protos.StatusResponse/estimate-num-keys int?)
(s/def :com.xtdb.protos.StatusResponse/size int?)


(s/def ::StatusResponse-spec (s/keys :opt-un [:com.xtdb.protos.StatusResponse/version :com.xtdb.protos.StatusResponse/index-version :com.xtdb.protos.StatusResponse/kv-store :com.xtdb.protos.StatusResponse/estimate-num-keys :com.xtdb.protos.StatusResponse/size ]))
(def StatusResponse-defaults {:version "" :index-version 0 :kv-store "" :estimate-num-keys 0 :size 0 })

(defn cis->StatusResponse
  "CodedInputStream to StatusResponse"
  [is]
  (->> (tag-map StatusResponse-defaults
         (fn [tag index]
             (case index
               1 [:version (serdes.core/cis->String is)]
               2 [:index-version (serdes.core/cis->Int32 is)]
               3 [:kv-store (serdes.core/cis->String is)]
               4 [:estimate-num-keys (serdes.core/cis->Int32 is)]
               5 [:size (serdes.core/cis->Int64 is)]
               6 [:revision (ecis->OptionString is)]
               7 [:consumer-state (ecis->OptionString is)]

               [index (serdes.core/cis->undefined tag is)]))
         is)
        (map->StatusResponse-record)))

(defn ecis->StatusResponse
  "Embedded CodedInputStream to StatusResponse"
  [is]
  (serdes.core/cis->embedded cis->StatusResponse is))

(defn new-StatusResponse
  "Creates a new instance from a map, similar to map->StatusResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StatusResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StatusResponse-spec init))))]}
  (-> (merge StatusResponse-defaults init)
      (cond-> (some? (get init :revision)) (update :revision new-OptionString))
      (cond-> (some? (get init :consumer-state)) (update :consumer-state new-OptionString))
      (map->StatusResponse-record)))

(defn pb->StatusResponse
  "Protobuf to StatusResponse"
  [input]
  (cis->StatusResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StatusResponse-meta {:type "com.xtdb.protos.StatusResponse" :decoder pb->StatusResponse})

