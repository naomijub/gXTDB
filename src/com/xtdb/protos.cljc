;;;----------------------------------------------------------------------------------
;;; Generated by protoc-gen-clojure.  DO NOT EDIT
;;;
;;; Message Implementation of package com.xtdb.protos
;;;----------------------------------------------------------------------------------
(ns com.xtdb.protos
  (:require [protojure.protobuf.protocol :as pb]
            [protojure.protobuf.serdes.core :as serdes.core]
            [protojure.protobuf.serdes.complex :as serdes.complex]
            [protojure.protobuf.serdes.utils :refer [tag-map]]
            [protojure.protobuf.serdes.stream :as serdes.stream]
            [com.xtdb.protos :as com.xtdb.protos]
            [com.google.protobuf :as com.google.protobuf]
            [clojure.set :as set]
            [clojure.spec.alpha :as s]))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Forward declarations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(declare cis->Empty)
(declare ecis->Empty)
(declare new-Empty)
(declare cis->StatusResponse)
(declare ecis->StatusResponse)
(declare new-StatusResponse)
(declare cis->Evict)
(declare ecis->Evict)
(declare new-Evict)
(declare cis->Put)
(declare ecis->Put)
(declare new-Put)
(declare cis->Delete)
(declare ecis->Delete)
(declare new-Delete)
(declare cis->SubmitRequest)
(declare ecis->SubmitRequest)
(declare new-SubmitRequest)
(declare cis->SubmitResponse)
(declare ecis->SubmitResponse)
(declare new-SubmitResponse)
(declare cis->OptionDatetime)
(declare ecis->OptionDatetime)
(declare new-OptionDatetime)
(declare cis->Transaction)
(declare ecis->Transaction)
(declare new-Transaction)
(declare cis->OptionString)
(declare ecis->OptionString)
(declare new-OptionString)
(declare cis->Match)
(declare ecis->Match)
(declare new-Match)

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Enumerations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; IdType
;-----------------------------------------------------------------------------
(def IdType-default :uuid)

(def IdType-val2label {0 :uuid
                       1 :keyword
                       2 :string
                       3 :int})

(def IdType-label2val (set/map-invert IdType-val2label))

(defn cis->IdType [is]
  (let [val (serdes.core/cis->Enum is)]
    (get IdType-val2label val val)))

(defn- get-IdType [value]
  {:pre [(or (int? value) (contains? IdType-label2val value))]}
  (get IdType-label2val value value))

(defn write-IdType
  ([tag value os] (write-IdType tag {:optimize false} value os))
  ([tag options value os]
   (serdes.core/write-Enum tag options (get-IdType value) os)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; OptionDatetime-value's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-OptionDatetime-value [origkeyval]
  (cond
    (get-in origkeyval [:value :none]) (update-in origkeyval [:value :none] new-Empty)
    (get-in origkeyval [:value :some]) origkeyval
    :default origkeyval))

(defn write-OptionDatetime-value [value os]
  (let [field (first value)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :none (serdes.core/write-embedded 1 v os)
      :some (serdes.core/write-String 2  {:optimize false} v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Transaction-transaction-type's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-Transaction-transaction-type [origkeyval]
  (cond
    (get-in origkeyval [:transaction-type :put]) (update-in origkeyval [:transaction-type :put] new-Put)
    (get-in origkeyval [:transaction-type :delete]) (update-in origkeyval [:transaction-type :delete] new-Delete)
    (get-in origkeyval [:transaction-type :evict]) (update-in origkeyval [:transaction-type :evict] new-Evict)
    (get-in origkeyval [:transaction-type :match]) (update-in origkeyval [:transaction-type :match] new-Match)
    :default origkeyval))

(defn write-Transaction-transaction-type [transaction-type os]
  (let [field (first transaction-type)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :put (serdes.core/write-embedded 1 v os)
      :delete (serdes.core/write-embedded 2 v os)
      :evict (serdes.core/write-embedded 3 v os)
      :match (serdes.core/write-embedded 4 v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; OptionString-value's oneof Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

(defn convert-OptionString-value [origkeyval]
  (cond
    (get-in origkeyval [:value :none]) (update-in origkeyval [:value :none] new-Empty)
    (get-in origkeyval [:value :some]) origkeyval
    :default origkeyval))

(defn write-OptionString-value [value os]
  (let [field (first value)
        k (when-not (nil? field) (key field))
        v (when-not (nil? field) (val field))]
    (case k
      :none (serdes.core/write-embedded 1 v os)
      :some (serdes.core/write-String 2  {:optimize false} v os)
      nil)))

;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------
;; Message Implementations
;;----------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; Empty
;-----------------------------------------------------------------------------
(defrecord Empty-record []
  pb/Writer
  (serialize [this os])
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Empty"))

(s/def ::Empty-spec (s/keys :opt-un []))
(def Empty-defaults {})

(defn cis->Empty
  "CodedInputStream to Empty"
  [is]
  (map->Empty-record (tag-map Empty-defaults (fn [tag index] (case index [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Empty
  "Embedded CodedInputStream to Empty"
  [is]
  (serdes.core/cis->embedded cis->Empty is))

(defn new-Empty
  "Creates a new instance from a map, similar to map->Empty except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Empty-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Empty-spec init))))]}
  (map->Empty-record (merge Empty-defaults init)))

(defn pb->Empty
  "Protobuf to Empty"
  [input]
  (cis->Empty (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Empty-meta {:type "com.xtdb.protos.Empty" :decoder pb->Empty})

;-----------------------------------------------------------------------------
; StatusResponse
;-----------------------------------------------------------------------------
(defrecord StatusResponse-record [version index-version kv-store estimate-num-keys size revision consumer-state]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:version this) os)
    (serdes.core/write-Int32 2  {:optimize true} (:index-version this) os)
    (serdes.core/write-String 3  {:optimize true} (:kv-store this) os)
    (serdes.core/write-Int32 4  {:optimize true} (:estimate-num-keys this) os)
    (serdes.core/write-Int64 5  {:optimize true} (:size this) os)
    (serdes.core/write-embedded 6 (:revision this) os)
    (serdes.core/write-embedded 7 (:consumer-state this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.StatusResponse"))

(s/def :com.xtdb.protos.StatusResponse/version string?)
(s/def :com.xtdb.protos.StatusResponse/index-version int?)
(s/def :com.xtdb.protos.StatusResponse/kv-store string?)
(s/def :com.xtdb.protos.StatusResponse/estimate-num-keys int?)
(s/def :com.xtdb.protos.StatusResponse/size int?)

(s/def ::StatusResponse-spec (s/keys :opt-un [:com.xtdb.protos.StatusResponse/version :com.xtdb.protos.StatusResponse/index-version :com.xtdb.protos.StatusResponse/kv-store :com.xtdb.protos.StatusResponse/estimate-num-keys :com.xtdb.protos.StatusResponse/size]))
(def StatusResponse-defaults {:version "" :index-version 0 :kv-store "" :estimate-num-keys 0 :size 0})

(defn cis->StatusResponse
  "CodedInputStream to StatusResponse"
  [is]
  (map->StatusResponse-record (tag-map StatusResponse-defaults (fn [tag index] (case index 1 [:version (serdes.core/cis->String is)] 2 [:index-version (serdes.core/cis->Int32 is)] 3 [:kv-store (serdes.core/cis->String is)] 4 [:estimate-num-keys (serdes.core/cis->Int32 is)] 5 [:size (serdes.core/cis->Int64 is)] 6 [:revision (ecis->OptionString is)] 7 [:consumer-state (ecis->OptionString is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->StatusResponse
  "Embedded CodedInputStream to StatusResponse"
  [is]
  (serdes.core/cis->embedded cis->StatusResponse is))

(defn new-StatusResponse
  "Creates a new instance from a map, similar to map->StatusResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::StatusResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::StatusResponse-spec init))))]}
  (-> (merge StatusResponse-defaults init)
      (cond-> (some? (get init :revision)) (update :revision new-OptionString))
      (cond-> (some? (get init :consumer-state)) (update :consumer-state new-OptionString))
      (map->StatusResponse-record)))

(defn pb->StatusResponse
  "Protobuf to StatusResponse"
  [input]
  (cis->StatusResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record StatusResponse-meta {:type "com.xtdb.protos.StatusResponse" :decoder pb->StatusResponse})

;-----------------------------------------------------------------------------
; Evict
;-----------------------------------------------------------------------------
(defrecord Evict-record [document-id id-type]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:document-id this) os)
    (write-IdType 2  {:optimize true} (:id-type this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Evict"))

(s/def :com.xtdb.protos.Evict/document-id string?)
(s/def :com.xtdb.protos.Evict/id-type (s/or :keyword keyword? :int int?))
(s/def ::Evict-spec (s/keys :opt-un [:com.xtdb.protos.Evict/document-id :com.xtdb.protos.Evict/id-type]))
(def Evict-defaults {:document-id "" :id-type IdType-default})

(defn cis->Evict
  "CodedInputStream to Evict"
  [is]
  (map->Evict-record (tag-map Evict-defaults (fn [tag index] (case index 1 [:document-id (serdes.core/cis->String is)] 2 [:id-type (cis->IdType is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Evict
  "Embedded CodedInputStream to Evict"
  [is]
  (serdes.core/cis->embedded cis->Evict is))

(defn new-Evict
  "Creates a new instance from a map, similar to map->Evict except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Evict-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Evict-spec init))))]}
  (map->Evict-record (merge Evict-defaults init)))

(defn pb->Evict
  "Protobuf to Evict"
  [input]
  (cis->Evict (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Evict-meta {:type "com.xtdb.protos.Evict" :decoder pb->Evict})

;-----------------------------------------------------------------------------
; Put
;-----------------------------------------------------------------------------
(defrecord Put-record [id-type xt-id document valid-time end-valid-time]
  pb/Writer
  (serialize [this os]
    (write-IdType 1  {:optimize true} (:id-type this) os)
    (serdes.core/write-String 2  {:optimize true} (:xt-id this) os)
    (serdes.core/write-embedded 3 (:document this) os)
    (serdes.core/write-embedded 4 (:valid-time this) os)
    (serdes.core/write-embedded 5 (:end-valid-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Put"))

(s/def :com.xtdb.protos.Put/id-type (s/or :keyword keyword? :int int?))
(s/def :com.xtdb.protos.Put/xt-id string?)

(s/def ::Put-spec (s/keys :opt-un [:com.xtdb.protos.Put/id-type :com.xtdb.protos.Put/xt-id]))
(def Put-defaults {:id-type IdType-default :xt-id ""})

(defn cis->Put
  "CodedInputStream to Put"
  [is]
  (map->Put-record (tag-map Put-defaults (fn [tag index] (case index 1 [:id-type (cis->IdType is)] 2 [:xt-id (serdes.core/cis->String is)] 3 [:document (com.google.protobuf/ecis->Struct is)] 4 [:valid-time (ecis->OptionDatetime is)] 5 [:end-valid-time (ecis->OptionDatetime is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Put
  "Embedded CodedInputStream to Put"
  [is]
  (serdes.core/cis->embedded cis->Put is))

(defn new-Put
  "Creates a new instance from a map, similar to map->Put except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Put-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Put-spec init))))]}
  (-> (merge Put-defaults init)
      (cond-> (some? (get init :document)) (update :document com.google.protobuf/new-Struct))
      (cond-> (some? (get init :valid-time)) (update :valid-time new-OptionDatetime))
      (cond-> (some? (get init :end-valid-time)) (update :end-valid-time new-OptionDatetime))
      (map->Put-record)))

(defn pb->Put
  "Protobuf to Put"
  [input]
  (cis->Put (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Put-meta {:type "com.xtdb.protos.Put" :decoder pb->Put})

;-----------------------------------------------------------------------------
; Delete
;-----------------------------------------------------------------------------
(defrecord Delete-record [document-id id-type valid-time end-valid-time]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:document-id this) os)
    (write-IdType 2  {:optimize true} (:id-type this) os)
    (serdes.core/write-embedded 3 (:valid-time this) os)
    (serdes.core/write-embedded 4 (:end-valid-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Delete"))

(s/def :com.xtdb.protos.Delete/document-id string?)
(s/def :com.xtdb.protos.Delete/id-type (s/or :keyword keyword? :int int?))

(s/def ::Delete-spec (s/keys :opt-un [:com.xtdb.protos.Delete/document-id :com.xtdb.protos.Delete/id-type]))
(def Delete-defaults {:document-id "" :id-type IdType-default})

(defn cis->Delete
  "CodedInputStream to Delete"
  [is]
  (map->Delete-record (tag-map Delete-defaults (fn [tag index] (case index 1 [:document-id (serdes.core/cis->String is)] 2 [:id-type (cis->IdType is)] 3 [:valid-time (ecis->OptionDatetime is)] 4 [:end-valid-time (ecis->OptionDatetime is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Delete
  "Embedded CodedInputStream to Delete"
  [is]
  (serdes.core/cis->embedded cis->Delete is))

(defn new-Delete
  "Creates a new instance from a map, similar to map->Delete except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Delete-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Delete-spec init))))]}
  (-> (merge Delete-defaults init)
      (cond-> (some? (get init :valid-time)) (update :valid-time new-OptionDatetime))
      (cond-> (some? (get init :end-valid-time)) (update :end-valid-time new-OptionDatetime))
      (map->Delete-record)))

(defn pb->Delete
  "Protobuf to Delete"
  [input]
  (cis->Delete (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Delete-meta {:type "com.xtdb.protos.Delete" :decoder pb->Delete})

;-----------------------------------------------------------------------------
; SubmitRequest
;-----------------------------------------------------------------------------
(defrecord SubmitRequest-record [tx-ops]
  pb/Writer
  (serialize [this os]
    (serdes.complex/write-repeated serdes.core/write-embedded 1 (:tx-ops this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.SubmitRequest"))

(s/def ::SubmitRequest-spec (s/keys :opt-un []))
(def SubmitRequest-defaults {:tx-ops []})

(defn cis->SubmitRequest
  "CodedInputStream to SubmitRequest"
  [is]
  (map->SubmitRequest-record (tag-map SubmitRequest-defaults (fn [tag index] (case index 1 [:tx-ops (serdes.complex/cis->repeated ecis->Transaction is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->SubmitRequest
  "Embedded CodedInputStream to SubmitRequest"
  [is]
  (serdes.core/cis->embedded cis->SubmitRequest is))

(defn new-SubmitRequest
  "Creates a new instance from a map, similar to map->SubmitRequest except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SubmitRequest-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SubmitRequest-spec init))))]}
  (-> (merge SubmitRequest-defaults init)
      (cond-> (some? (get init :tx-ops)) (update :tx-ops #(map new-Transaction %)))
      (map->SubmitRequest-record)))

(defn pb->SubmitRequest
  "Protobuf to SubmitRequest"
  [input]
  (cis->SubmitRequest (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SubmitRequest-meta {:type "com.xtdb.protos.SubmitRequest" :decoder pb->SubmitRequest})

;-----------------------------------------------------------------------------
; SubmitResponse
;-----------------------------------------------------------------------------
(defrecord SubmitResponse-record [tx-time tx-id]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:tx-time this) os)
    (serdes.core/write-Int64 2  {:optimize true} (:tx-id this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.SubmitResponse"))

(s/def :com.xtdb.protos.SubmitResponse/tx-time string?)
(s/def :com.xtdb.protos.SubmitResponse/tx-id int?)
(s/def ::SubmitResponse-spec (s/keys :opt-un [:com.xtdb.protos.SubmitResponse/tx-time :com.xtdb.protos.SubmitResponse/tx-id]))
(def SubmitResponse-defaults {:tx-time "" :tx-id 0})

(defn cis->SubmitResponse
  "CodedInputStream to SubmitResponse"
  [is]
  (map->SubmitResponse-record (tag-map SubmitResponse-defaults (fn [tag index] (case index 1 [:tx-time (serdes.core/cis->String is)] 2 [:tx-id (serdes.core/cis->Int64 is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->SubmitResponse
  "Embedded CodedInputStream to SubmitResponse"
  [is]
  (serdes.core/cis->embedded cis->SubmitResponse is))

(defn new-SubmitResponse
  "Creates a new instance from a map, similar to map->SubmitResponse except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::SubmitResponse-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::SubmitResponse-spec init))))]}
  (map->SubmitResponse-record (merge SubmitResponse-defaults init)))

(defn pb->SubmitResponse
  "Protobuf to SubmitResponse"
  [input]
  (cis->SubmitResponse (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record SubmitResponse-meta {:type "com.xtdb.protos.SubmitResponse" :decoder pb->SubmitResponse})

;-----------------------------------------------------------------------------
; OptionDatetime
;-----------------------------------------------------------------------------
(defrecord OptionDatetime-record [value]
  pb/Writer
  (serialize [this os]
    (write-OptionDatetime-value  (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.OptionDatetime"))

(s/def ::OptionDatetime-spec (s/keys :opt-un []))
(def OptionDatetime-defaults {})

(defn cis->OptionDatetime
  "CodedInputStream to OptionDatetime"
  [is]
  (map->OptionDatetime-record (tag-map OptionDatetime-defaults (fn [tag index] (case index 1 [:value {:none (ecis->Empty is)}] 2 [:value {:some (serdes.core/cis->String is)}] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->OptionDatetime
  "Embedded CodedInputStream to OptionDatetime"
  [is]
  (serdes.core/cis->embedded cis->OptionDatetime is))

(defn new-OptionDatetime
  "Creates a new instance from a map, similar to map->OptionDatetime except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OptionDatetime-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OptionDatetime-spec init))))]}
  (-> (merge OptionDatetime-defaults init)
      (convert-OptionDatetime-value)
      (map->OptionDatetime-record)))

(defn pb->OptionDatetime
  "Protobuf to OptionDatetime"
  [input]
  (cis->OptionDatetime (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record OptionDatetime-meta {:type "com.xtdb.protos.OptionDatetime" :decoder pb->OptionDatetime})

;-----------------------------------------------------------------------------
; Transaction
;-----------------------------------------------------------------------------
(defrecord Transaction-record [transaction-type tx-time]
  pb/Writer
  (serialize [this os]
    (write-Transaction-transaction-type  (:transaction-type this) os)
    (serdes.core/write-embedded 5 (:tx-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Transaction"))

(s/def ::Transaction-spec (s/keys :opt-un []))
(def Transaction-defaults {})

(defn cis->Transaction
  "CodedInputStream to Transaction"
  [is]
  (map->Transaction-record (tag-map Transaction-defaults (fn [tag index] (case index 1 [:transaction-type {:put (ecis->Put is)}] 2 [:transaction-type {:delete (ecis->Delete is)}] 3 [:transaction-type {:evict (ecis->Evict is)}] 4 [:transaction-type {:match (ecis->Match is)}] 5 [:tx-time (ecis->OptionDatetime is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Transaction
  "Embedded CodedInputStream to Transaction"
  [is]
  (serdes.core/cis->embedded cis->Transaction is))

(defn new-Transaction
  "Creates a new instance from a map, similar to map->Transaction except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Transaction-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Transaction-spec init))))]}
  (-> (merge Transaction-defaults init)
      (cond-> (some? (get init :tx-time)) (update :tx-time new-OptionDatetime))
      (convert-Transaction-transaction-type)
      (map->Transaction-record)))

(defn pb->Transaction
  "Protobuf to Transaction"
  [input]
  (cis->Transaction (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Transaction-meta {:type "com.xtdb.protos.Transaction" :decoder pb->Transaction})

;-----------------------------------------------------------------------------
; OptionString
;-----------------------------------------------------------------------------
(defrecord OptionString-record [value]
  pb/Writer
  (serialize [this os]
    (write-OptionString-value  (:value this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.OptionString"))

(s/def ::OptionString-spec (s/keys :opt-un []))
(def OptionString-defaults {})

(defn cis->OptionString
  "CodedInputStream to OptionString"
  [is]
  (map->OptionString-record (tag-map OptionString-defaults (fn [tag index] (case index 1 [:value {:none (ecis->Empty is)}] 2 [:value {:some (serdes.core/cis->String is)}] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->OptionString
  "Embedded CodedInputStream to OptionString"
  [is]
  (serdes.core/cis->embedded cis->OptionString is))

(defn new-OptionString
  "Creates a new instance from a map, similar to map->OptionString except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::OptionString-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::OptionString-spec init))))]}
  (-> (merge OptionString-defaults init)
      (convert-OptionString-value)
      (map->OptionString-record)))

(defn pb->OptionString
  "Protobuf to OptionString"
  [input]
  (cis->OptionString (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record OptionString-meta {:type "com.xtdb.protos.OptionString" :decoder pb->OptionString})

;-----------------------------------------------------------------------------
; Match
;-----------------------------------------------------------------------------
(defrecord Match-record [document-id id-type document valid-time]
  pb/Writer
  (serialize [this os]
    (serdes.core/write-String 1  {:optimize true} (:document-id this) os)
    (write-IdType 2  {:optimize true} (:id-type this) os)
    (serdes.core/write-embedded 3 (:document this) os)
    (serdes.core/write-embedded 4 (:valid-time this) os))
  pb/TypeReflection
  (gettype [this]
    "com.xtdb.protos.Match"))

(s/def :com.xtdb.protos.Match/document-id string?)
(s/def :com.xtdb.protos.Match/id-type (s/or :keyword keyword? :int int?))

(s/def ::Match-spec (s/keys :opt-un [:com.xtdb.protos.Match/document-id :com.xtdb.protos.Match/id-type]))
(def Match-defaults {:document-id "" :id-type IdType-default})

(defn cis->Match
  "CodedInputStream to Match"
  [is]
  (map->Match-record (tag-map Match-defaults (fn [tag index] (case index 1 [:document-id (serdes.core/cis->String is)] 2 [:id-type (cis->IdType is)] 3 [:document (com.google.protobuf/ecis->Struct is)] 4 [:valid-time (ecis->OptionDatetime is)] [index (serdes.core/cis->undefined tag is)])) is)))

(defn ecis->Match
  "Embedded CodedInputStream to Match"
  [is]
  (serdes.core/cis->embedded cis->Match is))

(defn new-Match
  "Creates a new instance from a map, similar to map->Match except that
  it properly accounts for nested messages, when applicable.
  "
  [init]
  {:pre [(if (s/valid? ::Match-spec init) true (throw (ex-info "Invalid input" (s/explain-data ::Match-spec init))))]}
  (-> (merge Match-defaults init)
      (cond-> (some? (get init :document)) (update :document com.google.protobuf/new-Struct))
      (cond-> (some? (get init :valid-time)) (update :valid-time new-OptionDatetime))
      (map->Match-record)))

(defn pb->Match
  "Protobuf to Match"
  [input]
  (cis->Match (serdes.stream/new-cis input)))

(def ^:protojure.protobuf.any/record Match-meta {:type "com.xtdb.protos.Match" :decoder pb->Match})

